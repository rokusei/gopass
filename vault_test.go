package gopass

import (
	"bytes"
	"encoding/hex"
	"testing"

	"github.com/stretchr/testify/require"
)

func Test_generateEncryptionKeyAuthenticationHash(t *testing.T) {
	testCases := []struct {
		name           string
		masterPassword string
		salt           []byte
		ekhExpected    string
		ahExpected     string
	}{
		{
			name:           "test a",
			masterPassword: "password1",
			salt:           []byte("autogenerated"),
			ekhExpected:    "77f7e242de5663575f8bfc72f2a9c1e70ae896c4e317847dc75b034659e68d98",
			ahExpected:     "f4ca9cd1c35f13a16dc1063acad0372c78e5dd2a29e822f724aeac89c45dcd4107b580faeabb16c867099834cc0185578078cf8bda4ee59e40c81b31f63a4daf",
		},
	}
	for _, test := range testCases {
		ekActual := DeriveEncryptionKey(test.masterPassword, test.salt)
		ekh := hex.EncodeToString(ekActual)
		require.Equal(t, test.ekhExpected, ekh, test.name)

		aActual, err := DeriveAuthenticationHash(ekActual, test.salt)
		ah := hex.EncodeToString(aActual)
		require.NoError(t, err)
		require.Equal(t, test.ahExpected, ah, test.name)
	}
}

func Test_GenerateVaultEncryptDecrypt(t *testing.T) {
	tests := 3
	ahs := make([][]byte, tests)
	ehs := make([][]byte, tests)
	salts := make([][]byte, tests)
	for i := 0; i < tests; i++ {
		mp := "test"
		vs, err := GenerateVaultSecrets(mp)
		ahs[i] = vs.AuthenticationHash
		ehs[i] = vs.EncryptionKey
		salts[i] = vs.Salt
		require.NoError(t, err)
		require.Len(t, vs.AuthenticationHash, 64)
		require.Len(t, vs.EncryptionKey, 32)
		require.GreaterOrEqual(t, bytes.Count(vs.Salt, []byte("-")), 3)
		t.Logf("Master Password: %s\nEncryptionKey: %s\nAuthenticationHash: %s\nSalt: %s\n",
			mp, hex.EncodeToString(vs.EncryptionKey), hex.EncodeToString(vs.AuthenticationHash), vs.Salt)
		original := "hi"
		ciphertext, err := Encrypt([]byte(original), vs.EncryptionKey)
		require.NoError(t, err)
		plain, err := Decrypt(ciphertext, vs.EncryptionKey)
		require.NoError(t, err)
		require.Equal(t, original, string(plain))
	}
	for i := 0; i < tests; i++ {
		for j := i + 1; j < tests; j++ {
			require.NotEqual(t, ahs[i], ahs[j])
			require.NotEqual(t, ehs[i], ehs[j])
			require.NotEqual(t, salts[i], salts[j])
		}
	}
}
